<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>è¥¿ç“œåˆæˆå¤§æŒ‘æˆ˜</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Arial', sans-serif;
        }
        body {
            background-color: #f8f9fa;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            min-height: 100vh;
        }
        .game-title {
            font-size: 2.2rem;
            color: #e74c3c;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 15px;
        }
        .game-title span {
            display: inline-block;
            transform: rotate(-15deg);
        }
        .game-container {
            position: relative;
            background-color: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.05);
            padding: 20px;
            width: 100%;
            max-width: 500px;
        }
        canvas {
            width: 100%;
            border-radius: 10px;
            background-color: #f1f2f6;
        }
        .controls {
            margin-top: 20px;
            width: 100%;
        }
        .restart-btn {
            width: 100%;
            padding: 15px;
            background-color: #2ecc71;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.2rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .restart-btn:hover {
            background-color: #27ae60;
        }
        .score-display {
            margin-top: 15px;
            background-color: #ffeaa7;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            color: #d35400;
        }
        .game-rules {
            margin-top: 20px;
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            max-width: 500px;
            width: 100%;
        }
        .game-rules h3 {
            color: #3498db;
            margin-bottom: 10px;
        }
        .game-rules ul {
            padding-left: 20px;
            line-height: 1.6;
        }
        /* æ°´æœå›¾æ ‡å¤§å°å˜åŒ–åŠ¨ç”» */
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }
        .merged-animation {
            animation: pulse 0.3s ease-in-out;
        }
    </style>
</head>
<body>
    <div class="game-title">
        ğŸ‰ è¥¿ç“œåˆæˆå¤§æŒ‘æˆ˜ ğŸ‰
    </div>
    
    <div class="game-container">
        <canvas id="gameCanvas" width="460" height="600"></canvas>
        
        <div class="controls">
            <button class="restart-btn" id="restartBtn">é‡æ–°å¼€å§‹</button>
            <div class="score-display">å¾—åˆ†: <span id="scoreValue">0</span></div>
        </div>
    </div>
    
    <div class="game-rules">
        <h3>æ¸¸æˆè§„åˆ™</h3>
        <ul>
            <li>æ°´æœä¼šä»é¡¶éƒ¨æ‰è½ï¼Œå·¦å³æ»‘åŠ¨å¯ä»¥æ§åˆ¶æ°´æœä½ç½®</li>
            <li>ä¸¤ä¸ªç›¸åŒæ°´æœç¢°æ’ä¼šåˆæˆæ›´é«˜çº§çš„æ°´æœ</li>
            <li>åˆæˆè·¯å¾„: æ¨±æ¡ƒğŸ’â†’è‰è“ğŸ“â†’è‘¡è„ğŸ‡â†’æ©™å­ğŸŠâ†’è‹¹æœğŸâ†’å“ˆå¯†ç“œğŸˆâ†’è¥¿ç“œğŸ‰</li>
            <li>æ°´æœå †åˆ°é¡¶éƒ¨æ¸¸æˆç»“æŸ</li>
        </ul>
    </div>

    <script>
        // è·å–DOMå…ƒç´ 
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const restartBtn = document.getElementById('restartBtn');
        const scoreValue = document.getElementById('scoreValue');
        
        // æ¸¸æˆå¸¸é‡
        const GRID_SIZE = 7;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const DROP_INTERVAL = 1000; // æ°´æœä¸‹è½é—´éš”(ms)
        const MOVE_INTERVAL = 150;   // è‡ªåŠ¨ä¸‹è½åŠ é€Ÿé—´éš”
        
        // æ°´æœç±»å‹å®šä¹‰
        const FRUIT_TYPES = [
            { emoji: 'ğŸ’', size: 0.8, score: 10 },  // æ¨±æ¡ƒ
            { emoji: 'ğŸ“', size: 0.9, score: 20 },  // è‰è“
            { emoji: 'ğŸ‡', size: 0.9, score: 30 },  // è‘¡è„
            { emoji: 'ğŸŠ', size: 1.0, score: 50 },  // æ©™å­
            { emoji: 'ğŸ', size: 1.0, score: 80 },  // è‹¹æœ
            { emoji: 'ğŸˆ', size: 1.1, score: 120 }, // å“ˆå¯†ç“œ
            { emoji: 'ğŸ‰', size: 1.2, score: 200 }  // è¥¿ç“œ
        ];
        
        // æ¸¸æˆå˜é‡
        let board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
        let currentFruit = null;
        let currentX = 0;
        let currentY = 0;
        let score = 0;
        let dropTimer = null;
        let moveTimer = null;
        let isGameOver = false;
        let lastMoveTime = 0;
        let isAccelerating = false;
        
        // åˆå§‹åŒ–æ¸¸æˆ
        function initGame() {
            // æ¸…ç©ºæ¸¸æˆæ¿
            board = Array(GRID_SIZE).fill().map(() => Array(GRID_SIZE).fill(null));
            
            // é‡ç½®çŠ¶æ€
            score = 0;
            isGameOver = false;
            updateScore();
            
            // æ¸…é™¤è®¡æ—¶å™¨
            if (dropTimer) clearInterval(dropTimer);
            if (moveTimer) clearInterval(moveTimer);
            
            // åˆ›å»ºç¬¬ä¸€ä¸ªæ°´æœ
            createNewFruit();
            
            // è®¾ç½®ä¸‹è½è®¡æ—¶å™¨
            dropTimer = setInterval(moveDown, DROP_INTERVAL);
            
            // å¼€å§‹æ¸¸æˆå¾ªç¯
            gameLoop();
            
            // è§¦æ‘¸å’Œé”®ç›˜æ§åˆ¶
            setupControls();
        }
        
        // åˆ›å»ºæ–°æ°´æœ
        function createNewFruit() {
            // éšæœºç”Ÿæˆä½çº§åˆ«æ°´æœ
            const fruitType = Math.floor(Math.random() * 3);
            
            // ä»é¡¶éƒ¨ä¸­é—´ä½ç½®å¼€å§‹
            currentX = Math.floor(GRID_SIZE / 2);
            currentY = 0;
            
            // æ£€æŸ¥æ¸¸æˆæ˜¯å¦ç»“æŸ(é¡¶éƒ¨æ˜¯å¦æœ‰æ°´æœ)
            if (board[currentY][currentX] !== null) {
                gameOver();
                return;
            }
            
            currentFruit = {
                type: fruitType,
                x: currentX,
                y: currentY
            };
        }
        
        // ç»˜åˆ¶æ¸¸æˆ
        function drawGame() {
            // æ¸…ç©ºç”»å¸ƒ
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // ç»˜åˆ¶ç½‘æ ¼å’Œæ°´æœ
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    // ç»˜åˆ¶å•å…ƒæ ¼
                    ctx.strokeStyle = 'rgba(0,0,0,0.05)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(
                        x * CELL_SIZE, 
                        y * CELL_SIZE, 
                        CELL_SIZE, 
                        CELL_SIZE
                    );
                    
                    // ç»˜åˆ¶æ°´æœ
                    const fruit = board[y][x];
                    if (fruit !== null) {
                        drawFruit(x, y, fruit);
                    }
                }
            }
            
            // ç»˜åˆ¶å½“å‰ä¸‹è½çš„æ°´æœ
            if (currentFruit) {
                drawFruit(currentFruit.x, currentFruit.y, currentFruit.type);
            }
            
            // ç»˜åˆ¶æ¸¸æˆç»“æŸæ–‡å­—
            if (isGameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, canvas.height/2 - 40, canvas.width, 80);
                ctx.fillStyle = 'white';
                ctx.font = '2rem Arial';
                ctx.textAlign = 'center';
                ctx.fillText('æ¸¸æˆç»“æŸ!', canvas.width/2, canvas.height/2);
            }
        }
        
        // ç»˜åˆ¶å•ä¸ªæ°´æœ
        function drawFruit(x, y, type) {
            const fruitInfo = FRUIT_TYPES[type];
            const size = CELL_SIZE * fruitInfo.size * 0.5;
            
            ctx.font = `${size}px Arial`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // è®¡ç®—ä½ç½®
            const posX = x * CELL_SIZE + CELL_SIZE / 2;
            const posY = y * CELL_SIZE + CELL_SIZE / 2;
            
            ctx.fillText(fruitInfo.emoji, posX, posY);
        }
        
        // ç§»åŠ¨æ°´æœå‘å·¦
        function moveLeft() {
            if (isGameOver) return;
            
            if (currentFruit.x > 0 && !checkCollision(currentFruit.x - 1, currentFruit.y)) {
                currentFruit.x--;
            }
        }
        
        // ç§»åŠ¨æ°´æœå‘å³
        function moveRight() {
            if (isGameOver) return;
            
            if (currentFruit.x < GRID_SIZE - 1 && !checkCollision(currentFruit.x + 1, currentFruit.y)) {
                currentFruit.x++;
            }
        }
        
        // ä¸‹ç§»æ°´æœ
        function moveDown() {
            if (isGameOver) return;
            
            // æ£€æŸ¥æ˜¯å¦å¯ä»¥ä¸‹ç§»
            if (currentFruit.y + 1 < GRID_SIZE && !checkCollision(currentFruit.x, currentFruit.y + 1)) {
                currentFruit.y++;
            } else {
                // ä¸èƒ½ä¸‹ç§»ï¼Œå›ºå®šæ°´æœå¹¶æ£€æŸ¥åˆå¹¶
                fixFruit();
                checkMerges();
                createNewFruit();
            }
            
            lastMoveTime = Date.now();
        }
        
        // å¿«é€Ÿä¸‹è½
        function quickDrop() {
            if (isGameOver) return;
            
            // ä¸€æ¬¡æ€§è½åˆ°æœ€åº•éƒ¨
            while (currentFruit.y + 1 < GRID_SIZE && !checkCollision(currentFruit.x, currentFruit.y + 1)) {
                currentFruit.y++;
            }
            
            fixFruit();
            checkMerges();
            createNewFruit();
        }
        
        // å›ºå®šæ°´æœä½ç½®
        function fixFruit() {
            board[currentFruit.y][currentFruit.x] = currentFruit.type;
        }
        
        // æ£€æŸ¥ç¢°æ’
        function checkCollision(x, y) {
            return board[y][x] !== null;
        }
        
        // æ£€æŸ¥å¹¶å¤„ç†æ°´æœåˆå¹¶
        function checkMerges() {
            let merged = false;
            
            // éå†æ•´ä¸ªæ¸¸æˆæ¿æ£€æŸ¥å¯åˆå¹¶çš„æ°´æœ
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (board[y][x] !== null) {
                        // æ£€æŸ¥å³ä¾§æ°´æœ
                        if (x + 1 < GRID_SIZE && board[y][x] === board[y][x + 1]) {
                            mergeFruits(x, y, x + 1, y);
                            merged = true;
                            return; // ä¸€æ¬¡åˆå¹¶ä¸€ä¸ª
                        }
                        
                        // æ£€æŸ¥ä¸‹æ–¹æ°´æœ
                        if (y + 1 < GRID_SIZE && board[y][x] === board[y + 1][x]) {
                            mergeFruits(x, y, x, y + 1);
                            merged = true;
                            return; // ä¸€æ¬¡åˆå¹¶ä¸€ä¸ª
                        }
                    }
                }
            }
            
            // å¦‚æœæœ‰åˆå¹¶ï¼Œç»§ç»­æ£€æŸ¥(å¯èƒ½äº§ç”Ÿæ–°çš„å¯åˆå¹¶å¯¹)
            if (merged) {
                setTimeout(checkMerges, 100);
            }
        }
        
        // åˆå¹¶æ°´æœ
        function mergeFruits(x1, y1, x2, y2) {
            const fruitType = board[y1][x1];
            
            // åªæœ‰éæœ€é«˜çº§æ°´æœå¯ä»¥åˆå¹¶
            if (fruitType >= FRUIT_TYPES.length - 1) return;
            
            // å¢åŠ åˆ†æ•°
            score += FRUIT_TYPES[fruitType].score;
            updateScore();
            
            // åˆ›å»ºæ›´é«˜çº§çš„æ°´æœ
            const newType = fruitType + 1;
            
            // æ¸…é™¤åŸæ°´æœä½ç½®
            board[y1][x1] = null;
            board[y2][x2] = null;
            
            // åœ¨ä½ç½®è¾ƒé«˜çš„åœ°æ–¹æ”¾ç½®æ–°æ°´æœ
            const newY = Math.min(y1, y2);
            const newX = Math.min(x1, x2);
            board[newY][newX] = newType;
            
            // æ·»åŠ åˆå¹¶åŠ¨ç”»æ•ˆæœ
            animateMerge(newX, newY);
        }
        
        // åˆå¹¶åŠ¨ç”»
        function animateMerge(x, y) {
            // è¿™é‡Œå¯ä»¥æ·»åŠ è§†è§‰åé¦ˆ
            const fruitType = board[y][x];
            const fruitInfo = FRUIT_TYPES[fruitType];
            
            // ç®€å•çš„ç¼©æ”¾åŠ¨ç”»
            setTimeout(() => {
                drawGame();
            }, 50);
        }
        
        // æ›´æ–°åˆ†æ•°æ˜¾ç¤º
        function updateScore() {
            scoreValue.textContent = score;
        }
        
        // æ¸¸æˆç»“æŸ
        function gameOver() {
            isGameOver = true;
            clearInterval(dropTimer);
            clearInterval(moveTimer);
        }
        
        // æ¸¸æˆå¾ªç¯
        function gameLoop() {
            drawGame();
            
            // å¤„ç†åŠ é€Ÿä¸‹è½
            if (!isGameOver && Date.now() - lastMoveTime > MOVE_INTERVAL) {
                moveDown();
            }
            
            requestAnimationFrame(gameLoop);
        }
        
        // è®¾ç½®æ§åˆ¶
        function setupControls() {
            // é”®ç›˜æ§åˆ¶
            window.addEventListener('keydown', (e) => {
                if (isGameOver) return;
                
                switch (e.key) {
                    case 'ArrowLeft':
                    case 'a':
                    case 'A':
                        moveLeft();
                        break;
                    case 'ArrowRight':
                    case 'd':
                    case 'D':
                        moveRight();
                        break;
                    case 'ArrowDown':
                    case 's':
                    case 'S':
                        moveDown();
                        break;
                    case 'ArrowUp':
                    case 'w':
                    case 'W':
                        quickDrop();
                        break;
                }
            });
            
            // è§¦æ‘¸æ§åˆ¶
            let touchStartX = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                touchStartX = e.touches[0].clientX;
                e.preventDefault();
            });
            
            canvas.addEventListener('touchmove', (e) => {
                if (isGameOver) return;
                
                const touchX = e.touches[0].clientX;
                const diffX = touchX - touchStartX;
                
                if (Math.abs(diffX) > 20) { // æ£€æµ‹åˆ°è¶³å¤Ÿçš„æ»‘åŠ¨è·ç¦»
                    if (diffX > 0) {
                        moveRight();
                    } else {
                        moveLeft();
                    }
                    touchStartX = touchX; // é‡ç½®èµ·ç‚¹ä»¥æ”¯æŒè¿ç»­æ»‘åŠ¨
                }
                e.preventDefault();
            });
            
            canvas.addEventListener('touchend', (e) => {
                // è½»è§¦ä¸‹è½
                quickDrop();
                e.preventDefault();
            });
        }
        
        // äº‹ä»¶ç›‘å¬
        restartBtn.addEventListener('click', initGame);
        
        // åˆå§‹åŒ–æ¸¸æˆ
        initGame();
    </script>
</body>
</html>
